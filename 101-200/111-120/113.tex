\documentclass{article} 
\begin{comment}
	tag:
	template
\end{comment}
\begin{document}
	
	\paragraph*{Question 113} $\boxed{\text{Difficulty: Medium}} $			
	
	According to the C++17 standard, what is the output of this program?
	
	\begin{lstlisting}[language=C++]  		
#include <iostream>

using namespace std;

template<typename T>
void f(T) {
	cout << 1;
}

template<>
void f(int) {
	cout << 2;
}

void f(int) {
	cout << 3;
}

int main() {
	f(0.0);
	f(0);
	f<>(0);
}
	\end{lstlisting}
	
	
	\paragraph*{答案和解析} $\boxed{\text{程序完全正确，输出为：132}} $
	
	此处有三个不同的 f 函数。 第一个是函数模板, 第二个是模板的特化, 第三个是普通的函数。

	第一次调用时, 对于函数模板, T 被推导为 double, 因此不适用模板特化。而函数模板 f(double) 是一次完美匹配(Exact Match), 因此选用第一个函数。
	第二次调用时, 对于函数模板, T 被推导为 int, 使用模板特化。此时有特化的 f<>(int) 和普通函数 f(int) 进入重载决议。 两者都是完美匹配级别, 但根据 \href{https://timsong-cpp.github.io/cppwp/n4659/over.match.best#1.6}{[over.match.best\#1.6]}, 我们优先选择非模板特化的函数。
	
	第三次调用中, \href{https://timsong-cpp.github.io/cppwp/n4659/temp.arg.explicit#4}{[temp.arg.explicit\#4]} 告诉我们, 在使用 f<> 进行调用时, 将优先使用模板特化的函数。
	\begin{lightgrayleftbar}
		Note: An empty template argument list can be used to indicate that a given use refers to a specialization of a function template even when a non-template function ([dcl.fct]) is visible that would otherwise be used.
	\end{lightgrayleftbar}

\end{document}