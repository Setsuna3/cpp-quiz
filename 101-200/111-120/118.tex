\documentclass{article} 

\begin{comment}
	tag:
	函数重载
\end{comment}

\begin{document}
	\paragraph*{Question 118} $\boxed{\text{Difficulty: Easy}} $	
	
According to the C++17 standard, what is the output of this program?	

	\begin{lstlisting}[language=C++]
#include <iostream>

void print(char const *str) { std::cout << str; }
void print(short num) { std::cout << num; }

int main() {
	print("abc");
	print(0);
	print('A');
}
	\end{lstlisting}
	\paragraph*{答案和解析} $\boxed{\text{程序会导致编译错误}} $
	
	根据 \href{https://timsong-cpp.github.io/cppwp/n4659/over.match.best}{[over.match.best]}, 可以说一个函数 F1 比另一个函数 F2 更好( a viable function F1 is defined to be a better function than another viable function F2), 按照以下方法判定。
	
	\begin{itemize}
		\item 定义 $ICS_i(F)$ 是一种转换, 它将 F \textbf{接收到的参数列表} 的第 i 个变量转化为 F \textbf{定义时的第 i 个参数} 的对应类型。各种转换之间有排名, \href{https://timsong-cpp.github.io/cppwp/n4659/over.ics.scs#3}{[over.ics.scs\#3]} 给出了\textbf{标准转换}的排名规则。等级 1 是排名最高的, 等级 3 是排名最低的。
		\begin{itemize}
			\item 等级1 Exact Match
			\begin{itemize}
				\item Identity Transformation
				\begin{itemize}
					\item 无需转换
				\end{itemize} 
				\item Lvalue Transformation
				\begin{itemize}
					\item 左值到右值的转换
					\item 数组到指针的转换
					\item 函数到函数指针的转换
				\end{itemize}
				\item Qualification Adjustment
				\begin{itemize}
					\item Qualification conversions, 即由 T 到 const T/ voliatile T
					\item 函数指针到函数指针的转换
				\end{itemize}
			\end{itemize}	
			\item 等级2 Promotion
 			\begin{itemize}
				\item 整型提升(Integral promotions)
				\item 浮点提升(Floating-point promotion)
			\end{itemize}	
			\item 等级3 Conversion
			\begin{itemize}
				\item 整型之间的转换
				\item 浮点型之间的转换
				\item 整型和浮点型之间的转换
				\item 指针之间的转换(例如 T* 转为 void*, 或转为 std::nullptr\_t)
				\item 指向成员之间的指针的转换(例如 D 是 B 的父类, 由 B* 转为 D*)
			\end{itemize}	
		\end{itemize}
		判定法①: 若满足以下条件,则称 F1 比 F2 好。
		\item 对于任意的 $i$, $ICS_i(F1)$ 的排名都不比 $ICS_i(F2)$ 的排名低
		\item 对于某些 $i$, $ICS_i(F1)$ 的排名比 $ICS_i(F2)$ 的排名高。
		判定法②: 若满足以下条件,则称 F1 比 F2 好。
		\item F1 和 F2 对应的转换序列是标准转换序列, 且不考虑 Lvalue Transformation(左值到右值的转换, 数组到指针的转换, 函数到函数指针的转换) 的情况下, F1 对应的转换序列是 F2 对应转换序列的真子集。 
	\end{itemize}
	除了标准转换外, 还存在其他隐式转换。\href{https://timsong-cpp.github.io/cppwp/n4659/over.ics.rank}{[over.ics.rank]}给出了转换之间的排名规则。标准转换比用户定义的转换更好，用户定义的转换比省略号的转换更好。
	
	\begin{lightgrayleftbar}
		a standard conversion sequence is a better conversion sequence than a user-defined conversion sequence or an ellipsis conversion sequence, and
		a user-defined conversion sequence is a better conversion sequence than an ellipsis conversion sequence. 
	\end{lightgrayleftbar}
	
	对于函数重载二义性的处理, 还有许多复杂的规则, 可以在上述链接中找到更多规则和例子。
	
	根据以上判定方法,  'abc' 是 const char* 类型, 与第一个函数完美匹配, 没有办法转化为第二个函数的参数。
	
	对于字面量 0, 它可能是空指针, 也可能是 int 类型的 0。考察第一个函数, 解释为空指针可以转化使得参数匹配, 这一转化的等级为 5。考察第二个函数, 解释为整型的 0 可以转化为 short, 这一转化的等级为 5。因此两种转化的等级相同, 不能说一个函数比另一个函数更好。根据\href{https://timsong-cpp.github.io/cppwp/n4659/over.match.best#2}{[over.match.best\#2]}, 会引发二义性问题。
	
	\begin{lightgrayleftbar}
		If there is exactly one viable function that is a better function than all other viable functions, then it is the one selected by overload resolution; otherwise the call is ill-formed.
	\end{lightgrayleftbar}

	'A' 没有办法转化为第一个函数的参数, 转化为第二个函数的参数的转化等级为 5。
	
	给出两个额外练习。
	在 C++17 标准下, 下列程序的结果是:
	
	\begin{lstlisting}[language=C]
#include <iostream>

void print(const char *str) { std::cout << 1; }
void print(int num) { std::cout << 2; }
void print(unsigned int num) {std::cout << 3; }
int main() {
	print(0);
	print((short) 0);
	print((unsigned short) 0);
}
	\end{lstlisting}
	
	参考答案: 222
	
	第一次调用, 转化为 int 是完美匹配, 因此选用第二个函数。
	后两次调用, 转化为 int 只需要 integral promotion, 等级为 2, 比第三个函数要好。 
	
	在 C++ 17 标准下, 以下程序的结果是:
	\begin{lstlisting}[language=C]
#include <iostream>
void foo(int x, int y, const char* c)
{
	std::cout << 1;
}

void foo(int x, short y, std::string s)
{
	std::cout << 2;
}
int main() {
	short x = 1, y = 2;
	foo(x, y, "hello");
}
	\end{lstlisting}

	参考答案: 程序会导致编译错误。
	
	注意, 在第二个参数上, 第一个函数比第二个函数更差;在第三个参数上, 第一个函数比第二个函数更好。所以,没有办法分辨它们的优劣, 即使第一个函数无需用户转换。
\end{document}
