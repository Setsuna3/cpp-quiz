\documentclass{article} 
\begin{comment}
	tag:
	
\end{comment}
\begin{document}
	\paragraph*{Question 126} $\boxed{\text{Difficulty: Easy}} $			
	
	According to the C++17 standard, what is the output of this program?
	
	\begin{lstlisting}[language=C++]  		
#include<iostream>

int foo()
{
	return 10;
}

struct foobar
{
	static int x;
	static int foo()
	{
		return 11;
	}
};

int foobar::x = foo();

int main()
{
	std::cout << foobar::x;
}
	\end{lstlisting}
	
	
	\paragraph*{答案和解析} $\boxed{\text{程序完全正确, 输出为: 11}} $
	
	这个问题的关键在于, foo 进行名称查找(name lookup)的时候, 采用全局的 foo() 还是类内的foobar::foo()。
	
	\href{https://timsong-cpp.github.io/cppwp/n4659/basic.lookup.unqual#13}{[basic.lookup.unqual\#13]} 指出, 对于类内的静态成员定义时使用的名称进行名称查找, 等同于在类的成员函数中进行名称查找。
	
	\begin{lightgrayleftbar}
		A name used in the definition of a static data member of class X (after the qualified-id of the static member) is looked up \textbf{as if the name was used in a member function of X.}
	\end{lightgrayleftbar}
	
	在进行未限定作用域的时, 将先查找类内的 foobar::foo()。找到后, 名称查找直接结束。若没有找到, 将在更外层的作用域寻找 foo。
	
	因此, 答案为 11。
	
\end{document}
