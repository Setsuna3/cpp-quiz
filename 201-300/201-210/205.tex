\documentclass{article}
\begin{document}
	\paragraph*{Question 205} $\boxed{\text{Difficulty: Medium}} $			
	
	According to the C++17 standard, what is the output of this program?
	
	\begin{lstlisting}[language=C++]  		
#include <iostream>

int main() {
	constexpr unsigned int id = 100;
	unsigned char array[] = { id % 3, id % 5 };
	std::cout
	<< static_cast<unsigned int>(array[0])
	<< static_cast<unsigned int>(array[1]) ;
}
	\end{lstlisting}
	
	\paragraph*{答案和解析} $\boxed{\text{程序完全正确，输出为：10}} $
	
	本题的关键点在于 \verb|unsigned char array[] = {id % 3, id % 5}| 一句是否合法。按理说使用初始化列表对聚合体进行初始化时, 不允许发生窄化转换(narrowing conversion)(\href{https://timsong-cpp.github.io/cppwp/n4659/dcl.init.aggr#3}{[dcl.init.aggr\#3]})。
	
	然而, 对于这个例子而言, 实际上没有发生窄化转换。这需要说到它的定义。
	\href{https://timsong-cpp.github.io/cppwp/n4659/dcl.init.list#7.4}{[dcl.init.list\#7.4]}
	
	\begin{lightgrayleftbar}
		from an integer type or unscoped enumeration type to an integer type that cannot represent all the values of the original type, \textbf{except where the source is a constant expression whose value after integral promotions will fit into the target type. }
	\end{lightgrayleftbar}
	
	从范围更大的类型到范围更小的类型, 但是有一个例外————变换前, 类型是一个常量表达式, 其值在目标类型的可行范围内。
	
	这里, 1 和 0 都在 unsigned char 范围内, 且 id 是一个常量, 所以程序没有问题。
\end{document}
