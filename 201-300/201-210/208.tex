\documentclass{article} 
\begin{comment}
	tag:
	map
	构造函数
\end{comment}
\begin{document}
	
	\paragraph*{Question 208} $\boxed{\text{Difficulty: Easy}} $			
	
	According to the C++17 standard, what is the output of this program?
	
	\begin{lstlisting}[language=C++]  		
#include <iostream>
#include <map>
using namespace std;

bool default_constructed = false;
bool constructed = false;
bool assigned = false;

class C {
	public:
	C() { default_constructed = true; }
	C(int) { constructed = true; }
	C& operator=(const C&) { assigned = true; return *this;}
};

int main() {
	map<int, C> m;
	m[7] = C(1);
	
	cout << default_constructed << constructed << assigned;
}
	\end{lstlisting}
	
	
	\paragraph*{答案和解析} $\boxed{\text{程序完全正确, 输出为 : 111}} $
	
	关于这个问题, 我们需要先了解 map 的 [ ] 运算。\href{https://timsong-cpp.github.io/cppwp/n4659/map.access}{[map.access]} 指出, map 的 [ ] 运算符将执行以下操作。
	
	\begin{lightgrayleftbar}
	T\& operator[](const key\_type\& x);
	
	Effects: Equivalent to: return try\_­emplace(x).first->second;
	
	T\& operator[](key\_type\&\& x);
	
	\textbf{Effects: Equivalent to: return try\_­emplace(move(x)).first->second; }
	\end{lightgrayleftbar}
	
	这里的 7 是右值, 将优先匹配第二个函数。
	
	try\_emplace 的作用由 \href{https://timsong-cpp.github.io/cppwp/n4659/map.modifiers#8}{[map.modifiers\#8]} 给出。如果已经包含待插入的 k, 则无效。否则相当于插入一个类型为 value\_type 的元素, 即一个 key\_type, mapped\_type 的 pair。
	
	\begin{lightgrayleftbar}
		template <class $\cdots$ Args>
		
		pair<iterator, bool> try\_emplace(key\_type\&\& k, Args\&\& $\cdots$ args);
		
		Effects: If the map already contains an element whose key is equivalent to k, there is no effect. \textbf{Otherwise inserts an object of type value\_­type constructed with piecewise\_­construct, forward\_­as\_­tuple(std​::​move(k)), forward\_­as\_­tuple(std​::​forward<Args>(args)...)}.
	\end{lightgrayleftbar}

	\href{https://timsong-cpp.github.io/cppwp/n4659/map.overview#2}{[map.overview\#2]}
	\begin{lightgrayleftbar}
		For a map<Key,T> the key\_­type is Key and the value\_­type is pair<const Key,T>.
	\end{lightgrayleftbar}

	该元素按照以下方法构造: piecewise\_­construct, forward\_­as\_­tuple(std​::​move(k)), forward\_­as\_­tuple(std​::​forward<Args>(args)...). piecewise\_construct 是 pair 类型的一个构造函数(\href{https://timsong-cpp.github.io/cppwp/n4659/pairs.pair#14}{[pairs.pair\#14]}), 其参数是一个空类 piecewise\_construct\_t 和两个 tuple, 然后用两个 tuple 中的参数构造这两个对象。由于这里我们只传入了一个参数, 所以第二个元素将是空的, 即会调用默认构造函数 C()。
	
	mp[7] 的返回值是 try\_­emplace(move(x)).first $\to$ second;。 其中 try\_emplace 返回值的 first 表示对应的 pair(=<const Key, T>) 的迭代器。这个 pair 对象的 second 已经被构造完成, 因此 mp[7] = C(1) 不是一次初始化, 它将调用 operator=, 而 C(1) 则调用构造函数 C(int x)。
	
	根据以上, 三个函数都将被调用 (顺序是 2 1 3)。
	
	如果希望避免 operator= 和 C() 的构造, 我们可以采用以下方法:
	
	\begin{lstlisting}[language=C++]
m.try_emplace(7, C(1));
	\end{lstlisting}

	这样, 只会调用一次 C(1)。
\end{document}