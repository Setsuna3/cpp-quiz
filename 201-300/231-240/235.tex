\documentclass{article}
\begin{document}
	\paragraph*{Question 235} $\boxed{\text{Difficulty: Medium}} $			
	
	According to the C++17 standard, what is the output of this program?
	
	\begin{lstlisting}[language=C++]  		
#include <initializer_list>
#include <iostream>

class C {
	public:
	C() = default;
	C(const C&) { std::cout << 1; }
};

void f(std::initializer_list<C> i) {}

int main() {
	C c;
	std::initializer_list<C> i{c};
	f(i);
	f(i);
}
		
	\end{lstlisting}
	
	\paragraph*{答案和解析} $\boxed{\text{程序完全正确，输出为：1}} $
	
	\href{https://timsong-cpp.github.io/cppwp/n4659/dcl.init.list#5}{[dcl.init.list\#5]} 提到, 当使用初始化列表构造 std::initializer\_list 时, 每个元素都将采用复制初始化(copy-initialization) \textbf{构造一个临时数组对象}, 而 std::initializer\_list 则 \textbf{引用这个数组}。 因此这一过程调用一次复制构造函数。
	
	\begin{lightgrayleftbar}
		An object of type std​::​initializer\_­list<E> is constructed from an initializer list as if the implementation generated and materialized a prvalue of type 'array of N const E', where N is the number of elements in the initializer list. Each element of that array is \textbf{copy-initialized with the corresponding element} of the initializer list, and the std​::​initializer\_­list<E> object is constructed to \textbf{refer to that array}.
	\end{lightgrayleftbar}

	std::initializer\_list 只是一个数组的引用, 所以调用 f 的过程并不会发生数组元素的复制。
\end{document}
