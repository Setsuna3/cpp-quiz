\documentclass{article} 

\begin{document}
	\paragraph*{Exercise 4.1} 
	
	对于该程序的解读有误。事实上, 第二个函数根本就不能定义。\href{https://timsong-cpp.github.io/cppwp/n4659/over.load#3.4}{[over.load\#3.4]} 指出, 如果两个函数只在(最外层的) cv 限定符上不同, 则是一种重复定义。
	
	\begin{lightgrayleftbar}
		Parameter declarations that differ only in the presence or absence of const and/or volatile are equivalent. That is, the const and volatile type-specifiers for each parameter type are ignored when determining which function is being declared, defined, or called.
	\end{lightgrayleftbar}
	
	不过, 解读中提到的规则是正确的。如果你写:
	
	\begin{lstlisting}[language=C++]
#include <iostream>

void f(const char*) { std::cout << 1;}

void f(const char(&)[14]) { std::cout << 3;}

int main() {
	char s[] = "Hello, World!";
	f(s);
}
	\end{lstlisting}
	则选择第二个函数, 虽然两者的 Rank 都是 Exact Match, 但是第二个函数的标准转换序列(Identity conversion)是第一个函数的转换(Qualification conversion)的真子集。
	
	而如果改为 \verb|const char s[] = "Hello, World!";| 则不同, 虽然第一个函数确实做了一次 Array-to-pointer conversion, 但在真子集比较中并不考虑这一等级的变换, 因此导致二义性。
\end{document}
